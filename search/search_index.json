{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6249\u9875 Warning \u7531\u4e8e\u6280\u672f\u9650\u5236\uff0c\u73b0\u5728\u4e2d\u6587\u641c\u7d22\u529f\u80fd\u65e0\u6cd5\u5b8c\u5584\uff0c\u8bf7\u6ce8\u610f\u5f53\u641c\u7d22\u5173\u952e\u8bcd\u7684\u65f6\u5019\u81ea\u884c\u5206\u8bcd\uff0c\u4f8b\u5982\uff1a \u679c\u6728\u9999\u9ec4\u6843\u8461\u5f0f\u86cb\u631e \u65e0\u6cd5\u641c\u5230\u4efb\u4f55\u5185\u5bb9\u3002\u4f46\u53ef\u4ee5\u641c\u7d22 \u679c\u6728\u9999 \u9ec4\u6843 \u8461\u5f0f \u86cb\u631e \u5373\u53ef\u786e\u4fdd\u7d22\u5f15\u5230\u4e0a\u8ff0\u5185\u5bb9\u3002","title":"Home"},{"location":"#_1","text":"Warning \u7531\u4e8e\u6280\u672f\u9650\u5236\uff0c\u73b0\u5728\u4e2d\u6587\u641c\u7d22\u529f\u80fd\u65e0\u6cd5\u5b8c\u5584\uff0c\u8bf7\u6ce8\u610f\u5f53\u641c\u7d22\u5173\u952e\u8bcd\u7684\u65f6\u5019\u81ea\u884c\u5206\u8bcd\uff0c\u4f8b\u5982\uff1a \u679c\u6728\u9999\u9ec4\u6843\u8461\u5f0f\u86cb\u631e \u65e0\u6cd5\u641c\u5230\u4efb\u4f55\u5185\u5bb9\u3002\u4f46\u53ef\u4ee5\u641c\u7d22 \u679c\u6728\u9999 \u9ec4\u6843 \u8461\u5f0f \u86cb\u631e \u5373\u53ef\u786e\u4fdd\u7d22\u5f15\u5230\u4e0a\u8ff0\u5185\u5bb9\u3002","title":"\u6249\u9875"},{"location":"design-pattern/","text":"\u89c2\u5bdf\u8005\u6a21\u5f0f \u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u6709\u4e24\u4e2a\u91cd\u8981\u6982\u5ff5\uff0cObserver \u548c Subject\u3002\u89c2\u5bdf\u8005\u6a21\u5f0f\u7684\u672c\u8d28\u662f Subject \u5bf9\u8c61\u53d1\u751f\u53d8\u5316\u7684\u65f6\u5019\uff0c\u901a\u77e5\u6240\u6709\u89c2\u5bdf\u4e86\u8fd9\u4e2a Subject \u7684 Observer\uff0c\u800c Subject \u4e0d\u9700\u8981 Observer \u5b9e\u9645\u7c7b\u578b\u4fe1\u606f\u3002 class IObserver { public : virtual void OnNotify () = 0 ; }; class ISubject { private : std :: vector < IObserver > observers_ ; public : // \u5229\u7528\u8fd9\u4e2a\u65b9\u6cd5\u53ef\u4ee5\u5c06Observer\u5bf9\u8c61\u6ce8\u518c\u5230Subject\u5bf9\u8c61\u4e2d void RegisterObserver ( IObserver observer ) { observers_ . Add ( observer ); } protected : // \u5f53\u7c7b\u5bf9\u8c61\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u5019\uff0cNotifyObserver \u65b9\u6cd5\u901a\u77e5\u6240\u6709\u6ce8\u518c\u8fdb\uff08\u8c03\u7528 RegisterObserver\uff09\u8fd9\u4e2a\u7c7b\u5bf9\u8c61\u7684\u89c2\u5bdf\u8005 void NotifyObserver () { foreach ( auto observer : observers_ ) observer . OnNotify (); } }; // \u65b0\u521b\u5efa\u7684\u7c7b\u9700\u8981\u7ee7\u627f\u7684\u57fa\u7c7b class ImportantBaseClass {...}; // \u4f7f\u7528\u591a\u91cd\u7ee7\u627f\u3002\u82e5\u4e0d\u7ee7\u627f IObserve\uff0c\u800c\u5728 SubClass \u6dfb\u52a0 OnNotify \u65b9\u6cd5\uff0c\u5219\u65e0\u6cd5\u4f7f\u7528 Subject \u7684 Register \u65b9\u6cd5 class ObserverSubClass : public ImportantBaseClass , public IObserve {...}; observer class as instance - Software Engineering Stack Exchange \u21a9 Multiple Inheritance: What's a good example? - Stack Overflow \u21a9","title":"\u89c2\u5bdf\u8005\u6a21\u5f0f"},{"location":"design-pattern/#_1","text":"\u89c2\u5bdf\u8005\u6a21\u5f0f\u4e2d\u6709\u4e24\u4e2a\u91cd\u8981\u6982\u5ff5\uff0cObserver \u548c Subject\u3002\u89c2\u5bdf\u8005\u6a21\u5f0f\u7684\u672c\u8d28\u662f Subject \u5bf9\u8c61\u53d1\u751f\u53d8\u5316\u7684\u65f6\u5019\uff0c\u901a\u77e5\u6240\u6709\u89c2\u5bdf\u4e86\u8fd9\u4e2a Subject \u7684 Observer\uff0c\u800c Subject \u4e0d\u9700\u8981 Observer \u5b9e\u9645\u7c7b\u578b\u4fe1\u606f\u3002 class IObserver { public : virtual void OnNotify () = 0 ; }; class ISubject { private : std :: vector < IObserver > observers_ ; public : // \u5229\u7528\u8fd9\u4e2a\u65b9\u6cd5\u53ef\u4ee5\u5c06Observer\u5bf9\u8c61\u6ce8\u518c\u5230Subject\u5bf9\u8c61\u4e2d void RegisterObserver ( IObserver observer ) { observers_ . Add ( observer ); } protected : // \u5f53\u7c7b\u5bf9\u8c61\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u5019\uff0cNotifyObserver \u65b9\u6cd5\u901a\u77e5\u6240\u6709\u6ce8\u518c\u8fdb\uff08\u8c03\u7528 RegisterObserver\uff09\u8fd9\u4e2a\u7c7b\u5bf9\u8c61\u7684\u89c2\u5bdf\u8005 void NotifyObserver () { foreach ( auto observer : observers_ ) observer . OnNotify (); } }; // \u65b0\u521b\u5efa\u7684\u7c7b\u9700\u8981\u7ee7\u627f\u7684\u57fa\u7c7b class ImportantBaseClass {...}; // \u4f7f\u7528\u591a\u91cd\u7ee7\u627f\u3002\u82e5\u4e0d\u7ee7\u627f IObserve\uff0c\u800c\u5728 SubClass \u6dfb\u52a0 OnNotify \u65b9\u6cd5\uff0c\u5219\u65e0\u6cd5\u4f7f\u7528 Subject \u7684 Register \u65b9\u6cd5 class ObserverSubClass : public ImportantBaseClass , public IObserve {...}; observer class as instance - Software Engineering Stack Exchange \u21a9 Multiple Inheritance: What's a good example? - Stack Overflow \u21a9","title":"\u89c2\u5bdf\u8005\u6a21\u5f0f"},{"location":"github-project-boards/","text":"\u7ec4\u5185\u654f\u6377\u5f00\u53d1\u8bf4\u660e \u5de5\u4f5c\u6d41\u7a0b \u4efb\u52a1\u5212\u5206 Sprint \u5468\u671f\u76ee\u6807 Sprint \u5468\u671f\u4efb\u52a1\u6e05\u5355 \u96be\u5ea6\u6295\u70b9 \u4efb\u52a1\u5206\u914d \u8fdb\u884c\u4efb\u52a1 Github \u521b\u5efa\u65b0\u5206\u652f \u7f16\u7801 TDD \u6d4b\u8bd5\u9a71\u52a8 \u4ee3\u7801\u98ce\u683c\u89c4\u8303 Commit & Push Pull Request Code Review \u6bcf\u5468\u4f9d\u636e\u4efb\u52a1\u6570\u91cf\u8fdb\u884c\u591a\u6b21 Code Review \u5b8c\u6210\u4efb\u52a1 \u6587\u6863\u66f4\u65b0\u5230 Project/docs \u76ee\u5f55\u4e0b \u6d41\u7a0b \u65f6\u95f4\u8bf4\u660e \u65f6\u957f \u4f8b\u4f1a \u5de5\u4f5c\u65e5 \u6bcf\u65e5 10 min \u4efb\u52a1\u5212\u5206 \u5468\u4e00 30 min Code Review \u5468\u4e09\u3001\u5468\u4e94 - \u6587\u6863\u66f4\u65b0 \u5468\u4e94 - \u627e\u8001\u5f20 \u5468\u4e00/\u5468\u4e8c - Github Project Boards Kanban \u67e5\u770b/\u7ba1\u7406\u4efb\u52a1\u8fdb\u5ea6 Kanban \u5361\u7247\u7ba1\u7406 Pull Request \u8fdb\u5ea6 Kanban \u5361\u7247\u7ba1\u7406 Issue \u8fdb\u5ea6 Pull Request \u548c Code Review","title":"\u7ec4\u5185\u654f\u6377\u5f00\u53d1\u8bf4\u660e"},{"location":"github-project-boards/#_1","text":"","title":"\u7ec4\u5185\u654f\u6377\u5f00\u53d1\u8bf4\u660e"},{"location":"github-project-boards/#_2","text":"\u4efb\u52a1\u5212\u5206 Sprint \u5468\u671f\u76ee\u6807 Sprint \u5468\u671f\u4efb\u52a1\u6e05\u5355 \u96be\u5ea6\u6295\u70b9 \u4efb\u52a1\u5206\u914d \u8fdb\u884c\u4efb\u52a1 Github \u521b\u5efa\u65b0\u5206\u652f \u7f16\u7801 TDD \u6d4b\u8bd5\u9a71\u52a8 \u4ee3\u7801\u98ce\u683c\u89c4\u8303 Commit & Push Pull Request Code Review \u6bcf\u5468\u4f9d\u636e\u4efb\u52a1\u6570\u91cf\u8fdb\u884c\u591a\u6b21 Code Review \u5b8c\u6210\u4efb\u52a1 \u6587\u6863\u66f4\u65b0\u5230 Project/docs \u76ee\u5f55\u4e0b \u6d41\u7a0b \u65f6\u95f4\u8bf4\u660e \u65f6\u957f \u4f8b\u4f1a \u5de5\u4f5c\u65e5 \u6bcf\u65e5 10 min \u4efb\u52a1\u5212\u5206 \u5468\u4e00 30 min Code Review \u5468\u4e09\u3001\u5468\u4e94 - \u6587\u6863\u66f4\u65b0 \u5468\u4e94 - \u627e\u8001\u5f20 \u5468\u4e00/\u5468\u4e8c -","title":"\u5de5\u4f5c\u6d41\u7a0b"},{"location":"github-project-boards/#github-project-boards","text":"Kanban \u67e5\u770b/\u7ba1\u7406\u4efb\u52a1\u8fdb\u5ea6 Kanban \u5361\u7247\u7ba1\u7406 Pull Request \u8fdb\u5ea6 Kanban \u5361\u7247\u7ba1\u7406 Issue \u8fdb\u5ea6","title":"Github Project Boards"},{"location":"github-project-boards/#pull-request-code-review","text":"","title":"Pull Request \u548c Code Review"},{"location":"directx/","text":"DirectML \u6458\u8981 Hybrid Rendering \u603b\u7eb2\u3002\u672c\u9875\u5c06\u8bb2\u8ff0DirectML\u539f\u7406\uff0c\u7ed3\u6784\u8bbe\u8ba1\u53ca\u6e32\u67d3\u5b9e\u8df5\u3002\u6e90\u7801\u53ca\u76f8\u5173\u5de5\u5177\uff0c\u53ef\u53c2\u9605 Github \u9879\u76ee\u3002 RTX \u6e32\u67d3\u7ba1\u7ebf\u6982\u8ff0 THE HYBRID RENDERING MODEL Previously, real-time graphics relied on rasterizing triangles to render images. Now, with the introduction of RT Cores and Tensor Cores, Turing hardware enables real-time ray tracing for lighting and the use of AI for image enhancement and other applications. The graphics API has evolved in the same direction, with the introduction of DirectX Raytracing and Windows ML as part of the Windows 10 October 2018 update. Taken together, these changes enable a new rendering model, Hybrid Rendering, in which graphics applications use a combination of traditional rendering, ray traced rendering, and AI to produce amazing images in real time. DirectML \u5b9e\u65f6\u6e32\u67d3 ...domains such as games and engines... For reliable real-time, high-performance, low-latency, and/or resource-constrained scenarios...You can integrate DirectML directly into your existing engine or rendering pipeline. 1 TensorRT/ NGX \u5b9e\u65f6\u6e32\u67d3 NGX DNN models can interface with CUDA 10, the DirectX and Vulkan drivers, as well as take advantage of NVIDIA TensorRT... 2 Introduction to DirectML \u21a9 NVIDIA-Turing-Architecture-Whitepaper \u21a9","title":"\u6249\u9875"},{"location":"directx/#directml","text":"\u6458\u8981 Hybrid Rendering \u603b\u7eb2\u3002\u672c\u9875\u5c06\u8bb2\u8ff0DirectML\u539f\u7406\uff0c\u7ed3\u6784\u8bbe\u8ba1\u53ca\u6e32\u67d3\u5b9e\u8df5\u3002\u6e90\u7801\u53ca\u76f8\u5173\u5de5\u5177\uff0c\u53ef\u53c2\u9605 Github \u9879\u76ee\u3002","title":"DirectML"},{"location":"directx/#rtx","text":"THE HYBRID RENDERING MODEL Previously, real-time graphics relied on rasterizing triangles to render images. Now, with the introduction of RT Cores and Tensor Cores, Turing hardware enables real-time ray tracing for lighting and the use of AI for image enhancement and other applications. The graphics API has evolved in the same direction, with the introduction of DirectX Raytracing and Windows ML as part of the Windows 10 October 2018 update. Taken together, these changes enable a new rendering model, Hybrid Rendering, in which graphics applications use a combination of traditional rendering, ray traced rendering, and AI to produce amazing images in real time.","title":"RTX \u6e32\u67d3\u7ba1\u7ebf\u6982\u8ff0"},{"location":"directx/#directml_1","text":"...domains such as games and engines... For reliable real-time, high-performance, low-latency, and/or resource-constrained scenarios...You can integrate DirectML directly into your existing engine or rendering pipeline. 1","title":"DirectML \u5b9e\u65f6\u6e32\u67d3"},{"location":"directx/#tensorrt-ngx","text":"NGX DNN models can interface with CUDA 10, the DirectX and Vulkan drivers, as well as take advantage of NVIDIA TensorRT... 2 Introduction to DirectML \u21a9 NVIDIA-Turing-Architecture-Whitepaper \u21a9","title":"TensorRT/ NGX \u5b9e\u65f6\u6e32\u67d3"},{"location":"directx/architect/","text":"DirectML \u5de5\u4f5c\u6d41 \u521d\u59cb\u5316 \u521d\u59cb\u5316 Direct3D 12 \u8d44\u6e90 Direct3D 12 device command queue command list descriptor heaps. \u521d\u59cb\u5316 DirectML \u8d44\u6e90 Since you're doing machine learning inferencing as well as your rendering workload, create DirectML resources\u2014the DirectML device, and operator instances. If you have a machine learning model where you need to perform a particular type of convolution with a particular size of filter tensor with a particular data type, then those are all parameters into DirectML's convolution operator. \u521d\u59cb\u5316 DirectML Operator DirectML records work into Direct3D 12 command lists. So, once initialization is done, you record the binding and initialization of (for example) your convolution operator into your command list. Then, close and execute your command list on your queue as usual. \u8f7d\u5165\u6743\u91cd\u53c2\u6570\uff08\u5b98\u65b9\u6587\u6863\u5c06\u6b64\u653e\u8fdb\u6267\u884c\u6b65\u9aa4\uff09 Upload your weight tensors into resources. A tensor in DirectML is represented using a regular Direct3D 12 resource. For example, if you want to upload your weight data to the GPU, then you do that the same way you would with any other Direct3D 12 resource (use an upload heap, or the copy queue). \u6267\u884c \u7ed1\u5b9a Input/ Output Next, you need to bind those Direct3D 12 resources as your input and output tensors. Record into your command list the binding and the execution of your operators. \u6267\u884c DirectML Operator Close and execute your command list. \u7ec6\u8282 \u521d\u59cb\u5316 Direct3D 12 \u8d44\u6e90 class D3D12Context { public : D3D12Context (); ~ D3D12Context (); void InitD3d12 (); void InitDml (); void CloseExecuteResetWait (); private : com_ptr < ID3D12Device > d3d12_device_ ; com_ptr < ID3D12CommandQueue > command_queue_ ; com_ptr < ID3D12CommandAllocator > command_allocator_ ; com_ptr < ID3D12GraphicsCommandList > command_list_ ; com_ptr < IDMLDevice > dml_device_ ; }; \u521d\u59cb\u5316 DirectML \u8d44\u6e90 ... class BaseDmlOperator { public : BaseDmlOperator ( DML_OPERATOR_DESC desc ) : desc_ ( desc ){} ~ BaseDmlOperator (); void Init ( std :: shared_ptr < D3D12Context > p_context ) { CreateOperator ( p_context ); CreateDescriptorHeap ( p_context ); CreateBindingTable ( p_context ); InitOperator ( p_context ); } ... }","title":"DirectML \u5de5\u4f5c\u6d41"},{"location":"directx/architect/#directml","text":"","title":"DirectML \u5de5\u4f5c\u6d41"},{"location":"directx/architect/#_1","text":"","title":"\u521d\u59cb\u5316"},{"location":"directx/architect/#direct3d-12","text":"Direct3D 12 device command queue command list descriptor heaps.","title":"\u521d\u59cb\u5316 Direct3D 12 \u8d44\u6e90"},{"location":"directx/architect/#directml_1","text":"Since you're doing machine learning inferencing as well as your rendering workload, create DirectML resources\u2014the DirectML device, and operator instances. If you have a machine learning model where you need to perform a particular type of convolution with a particular size of filter tensor with a particular data type, then those are all parameters into DirectML's convolution operator.","title":"\u521d\u59cb\u5316 DirectML \u8d44\u6e90"},{"location":"directx/architect/#directml-operator","text":"DirectML records work into Direct3D 12 command lists. So, once initialization is done, you record the binding and initialization of (for example) your convolution operator into your command list. Then, close and execute your command list on your queue as usual.","title":"\u521d\u59cb\u5316 DirectML Operator"},{"location":"directx/architect/#_2","text":"Upload your weight tensors into resources. A tensor in DirectML is represented using a regular Direct3D 12 resource. For example, if you want to upload your weight data to the GPU, then you do that the same way you would with any other Direct3D 12 resource (use an upload heap, or the copy queue).","title":"\u8f7d\u5165\u6743\u91cd\u53c2\u6570\uff08\u5b98\u65b9\u6587\u6863\u5c06\u6b64\u653e\u8fdb\u6267\u884c\u6b65\u9aa4\uff09"},{"location":"directx/architect/#_3","text":"","title":"\u6267\u884c"},{"location":"directx/architect/#input-output","text":"Next, you need to bind those Direct3D 12 resources as your input and output tensors. Record into your command list the binding and the execution of your operators.","title":"\u7ed1\u5b9a Input/ Output"},{"location":"directx/architect/#directml-operator_1","text":"Close and execute your command list.","title":"\u6267\u884c DirectML Operator"},{"location":"directx/architect/#_4","text":"\u521d\u59cb\u5316 Direct3D 12 \u8d44\u6e90 class D3D12Context { public : D3D12Context (); ~ D3D12Context (); void InitD3d12 (); void InitDml (); void CloseExecuteResetWait (); private : com_ptr < ID3D12Device > d3d12_device_ ; com_ptr < ID3D12CommandQueue > command_queue_ ; com_ptr < ID3D12CommandAllocator > command_allocator_ ; com_ptr < ID3D12GraphicsCommandList > command_list_ ; com_ptr < IDMLDevice > dml_device_ ; };","title":"\u7ec6\u8282"},{"location":"directx/architect/#directml_2","text":"... class BaseDmlOperator { public : BaseDmlOperator ( DML_OPERATOR_DESC desc ) : desc_ ( desc ){} ~ BaseDmlOperator (); void Init ( std :: shared_ptr < D3D12Context > p_context ) { CreateOperator ( p_context ); CreateDescriptorHeap ( p_context ); CreateBindingTable ( p_context ); InitOperator ( p_context ); } ... }","title":"\u521d\u59cb\u5316 DirectML \u8d44\u6e90"},{"location":"directx/binding/","text":"DirectML \u4e2d\u7684\u8d44\u6e90\u7ed1\u5b9a 1 \u5c06\u8d44\u6e90\u7ed1\u5b9a\u5230 pipeline \u4e0a\uff0cDirectML \u8d44\u6e90\u5305\u542b\u4e0b\u9762\u51e0\u79cd Input Output Temporary Persistent \u672c\u6587\u5305\u542b\u7ed1\u5b9a\u7684\u6982\u5ff5\u53ca\u5b9e\u73b0\u7ec6\u8282 \u91cd\u8981\u6982\u5ff5 \u6267\u884c dispatchable\uff08operator initializer/ compiled operator\uff09\uff0c\u9700\u4f9d\u7167\u4ee5\u4e0b\u6b65\u9aa4\u8fdb\u884c\u3002 IDMLDispatchable::GetBindingProperties \u83b7\u53d6\u5f53\u524d dispatchable \u6240\u9700\u7684 descriptors \u6570\u91cf\uff0ctemporary/persistent \u8d44\u6e90 \u521b\u5efa\u8db3\u591f\u5bb9\u7eb3 descriptors \u7684 Direct3D 12 descriptor heap\uff0c\u7ed1\u5b9a\u5230 pipeline IDMLDevice::CreateBindingTable \u521b\u5efa DirectML \u7684 binding table\uff0c\u8868\u793a pipeline \u4e0a\u7684\u8d44\u6e90\u3002\u4f7f\u7528 DML_BINDING_TABLE_DESC \u7ed3\u6784\u6765\u63cf\u8ff0 binding table\u3002 \u521b\u5efa Direct3D 12 buffer \u683c\u5f0f\u7684 temporal/persistent \u8d44\u6e90\uff0c \u7528 DML_BUFFER_BINDING \u548c DML_BINDING_DESC \u63cf\u8ff0\uff0c\u6dfb\u52a0\u5230 binding table \u5f53 dispatchable \u4e3a compiled operator \u65f6\uff0c\u521b\u5efa Direct3D 12 buffer \u8d44\u6e90\uff0c\u6dfb\u52a0\u5230 binding table \u5c06 binding table \u4f5c\u4e3a\u53c2\u6570\u4f20\u5165 IDMLCommandRecorder::RecordDispatch \u83b7\u53d6 Binding Properties Note \u76f8\u540c\u7684 operator \u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684 binding properties DML_BINDING_PROPERTIES \u7ed3\u6784\u5b9a\u4e49\u4e86 dispatchable \u7ed1\u5b9a\u8d44\u6e90\u76f8\u5173\u6570\u636e\uff0c\u4e0b\u9762\u662f\u7ed3\u6784\u7684\u5b8c\u6574\u5b9a\u4e49 struct DML_BINDING_PROPERTIES { UINT RequiredDescriptorCount ; UINT64 TemporaryResourceSize ; UINT64 PersistentResourceSize ; }; \u4f7f\u7528 IDMLDispatchable::GetBindingProperties \u83b7\u53d6\u6570\u636e winrt :: com_ptr <:: IDMLCompiledOperator > dmlCompiledOperator ; // Code to create and compile a DirectML operator goes here. DML_BINDING_PROPERTIES executeDmlBindingProperties { dmlCompiledOperator -> GetBindingProperties () }; winrt :: com_ptr <:: IDMLOperatorInitializer > dmlOperatorInitializer ; // Code to create a DirectML operator initializer goes here. DML_BINDING_PROPERTIES initializeDmlBindingProperties { dmlOperatorInitializer -> GetBindingProperties () }; UINT descriptorCount = ... RequiredDescriptorCount\uff1aDescriptor Heap size TemporaryResourceSize PersistentResourceSize \u521b\u5efa Descriptor Heap DirectML \u5728 Heap \u4e0a\u521b\u5efa\u3001\u7ba1\u7406 Descriptors\u3002 D3D12_DESCRIPTOR_HEAP_DESC \u7ed3\u6784\u63cf\u8ff0 Heap ID3D12Device::CreateDescriptorHeap \u521b\u5efa Heap\u3002 ID3D12GraphicsCommandList::SetDescriptorHeaps \u5c06 Heap \u7ed1\u5b9a\u5230 pipeline\u3002 typedef struct D3D12_DESCRIPTOR_HEAP_DESC { D3D12_DESCRIPTOR_HEAP_TYPE Type ; UINT NumDescriptors ; D3D12_DESCRIPTOR_HEAP_FLAGS Flags ; UINT NodeMask ; } D3D12_DESCRIPTOR_HEAP_DESC ; winrt :: com_ptr <:: ID3D12DescriptorHeap > d3D12DescriptorHeap ; D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription {}; descriptorHeapDescription . Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV ; descriptorHeapDescription . NumDescriptors = descriptorCount ; descriptorHeapDescription . Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE ; winrt :: check_hresult ( d3D12Device -> CreateDescriptorHeap ( & descriptorHeapDescription , _uuidof ( d3D12DescriptorHeap ), d3D12DescriptorHeap . put_void () ) ); std :: array < ID3D12DescriptorHeap * , 1 > d3D12DescriptorHeaps { d3D12DescriptorHeap . get () }; d3D12GraphicsCommandList -> SetDescriptorHeaps ( static_cast < UINT > ( d3D12DescriptorHeaps . size ()), d3D12DescriptorHeaps . data () ); \u521b\u5efa Binding Table Binding Table \u7528\u4e8e\u8868\u793a dispatchable \u7684\u8d44\u6e90\u3002 Input Output Temporary Persistent DML_BINDING_TABLE_DESC \u7528\u4e8e\u63cf\u8ff0 binding table struct DML_BINDING_TABLE_DESC { IDMLDispatchable * Dispatchable ; D3D12_CPU_DESCRIPTOR_HANDLE CPUDescriptorHandle ; D3D12_GPU_DESCRIPTOR_HANDLE GPUDescriptorHandle ; UINT SizeInDescriptors ; }; IDMLDevice::CreateBindingTable \u65b9\u6cd5\u521b\u5efa DirectML binding table\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u521b\u5efa\u8d44\u6e90\uff0c\u5e76\u5c06\u8fd9\u4e9b\u8d44\u6e90\u6dfb\u52a0\u5230 binding table\u3002 DML_BINDING_TABLE_DESC dmlBindingTableDesc {}; dmlBindingTableDesc . Dispatchable = dmlOperatorInitializer . get (); dmlBindingTableDesc . CPUDescriptorHandle = d3D12DescriptorHeap -> GetCPUDescriptorHandleForHeapStart (); dmlBindingTableDesc . GPUDescriptorHandle = d3D12DescriptorHeap -> GetGPUDescriptorHandleForHeapStart (); dmlBindingTableDesc . SizeInDescriptors = descriptorCount ; winrt :: com_ptr <:: IDMLBindingTable > dmlBindingTable ; winrt :: check_hresult ( dmlDevice -> CreateBindingTable ( & dmlBindingTableDesc , __uuidof ( dmlBindingTable ), dmlBindingTable . put_void () ) ); DirectML \u5c06 Descriptor \u5199\u5165 Heap \u7684\u987a\u5e8f\u672a\u5b9a\u4e49\uff0c\u6ce8\u610f\u4e0d\u8981\u8986\u5199 binding table \u4e2d\u7684 descriptor \u4ee3\u7801\u4e2d\u6ce8\u610f\u5728\u6267\u884cbinding table \u524d\uff0c\u4fdd\u8bc1 CPU descriptors \u62f7\u8d1d\u5230 GPU \u4e2d Handle \u652f\u6301 D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV \u7c7b\u578b\u7684 descriptor heap heap \u5fc5\u987b\u662f shader-visible \u7684 \u91cd\u7f6e binding table \u79fb\u9664\u6240\u6709\u8d44\u6e90 \u4fee\u6539 binding table \u63cf\u8ff0 IDMLBindingTable::Reset dmlBindingTableDesc . Dispatchable = pIDMLCompiledOperator . get (); winrt :: check_hresult ( pIDMLBindingTable -> Reset ( & dmlBindingTableDesc ) ); \u7ed1\u5b9a Temporary/Persistent \u4f7f\u7528\u4ece dispatchable \u4e2d\u83b7\u53d6\u7684 binding \u53c2\u6570\u586b\u5145 DML_BINDING_PROPERTIES \u7ed3\u6784\u3002\u521b\u5efa Direct3D 12 buffer \u8d44\u6e90\uff0c\u6dfb\u52a0\u5230 binding table \u4e2d\u3002 D3D12_HEAP_PROPERTIES defaultHeapProperties { CD3DX12_HEAP_PROPERTIES ( D3D12_HEAP_TYPE_DEFAULT ) }; winrt :: com_ptr <:: ID3D12Resource > temporaryBuffer ; D3D12_RESOURCE_DESC temporaryBufferDesc { CD3DX12_RESOURCE_DESC :: Buffer ( temporaryResourceSize ) }; winrt :: check_hresult ( d3D12Device -> CreateCommittedResource ( & defaultHeapProperties , D3D12_HEAP_FLAG_NONE , & temporaryBufferDesc , D3D12_RESOURCE_STATE_COMMON , nullptr , __uuidof ( temporaryBuffer ), temporaryBuffer . put_void () ) ); DML_BUFFER_BINDING bufferBinding { temporaryBuffer . get (), 0 , temporaryResourceSize }; DML_BINDING_DESC bindingDesc { DML_BINDING_TYPE_BUFFER , & bufferBinding }; dmlBindingTable -> BindTemporaryResource ( & bindingDesc ); temporary \u8d44\u6e90\u662f operator \u6267\u884c\u8fc7\u7a0b\u4e2d\u5185\u90e8\u4f7f\u7528\u7684\u5b58\u50a8\u8d44\u6e90\uff08GPU Memory\uff09\uff0c\u7a0b\u5e8f\u4e0d\u9700\u8981\u5173\u5fc3 temporary \u8d44\u6e90\u7684\u5185\u5bb9\uff0c\u4e5f\u4e0d\u9700\u8981\u5728 IDMLCommandRecorder::RecordDispatch \u6267\u884c\u540e\u4fdd\u7559\u5b83\u3002\u7a0b\u5e8f\u53ef\u4ee5\u9009\u62e9\u91ca\u653e\u8d44\u6e90\uff0c\u6216\u8005\u5728\u4e0d\u540c\u7684 dispatch \u4e0a\u91cd\u7528\u8fd9\u5757\u8d44\u6e90\u3002 \u5bf9\u4e8e persistent \u8d44\u6e90\uff0c\u521b\u5efa\u6d41\u7a0b\u4e0e\u4e0a\u8ff0\u4e00\u81f4\u3002\u4f46\u9700\u4f7f\u7528 IDMLBindingTable::BindOutputs \u5c06\u8d44\u6e90\u6dfb\u52a0\u5230 operator initializer \u7684 binding table \u4e2d\uff0c\u521d\u59cb\u5316 persistent \u8d44\u6e90\u662f initializer \u7684\u804c\u8d23\uff0c\u7136\u540e\u4f7f\u7528 IDMLBindingTable::BindPersistentResource \u7ed1\u5b9a\u5230 compiled operator\u3002persistent \u8d44\u6e90\u7684\u751f\u547d\u5468\u671f\u548c operator \u4e00\u6837\u957f\u3002 persistent \u8d44\u6e90\u901a\u5e38\u7528\u4e8e\u5b58\u50a8\u67e5\u627e\u8868\u6216 operator initialization \u8ba1\u7b97\u51fa\u7684\u6570\u636e\uff0c\u8fd9\u4e9b\u6570\u636e\u88ab operator \u4f7f\u7528\u3002 \u7ed1\u5b9a Tensors compiled operator \u9700\u4e3a binding table \u7ed1\u5b9a input \u548c output \u8d44\u6e90\u3002 \u7528 DML_BUFFER_BINDING \u548c DML_BINDING_DESC \u7ed3\u6784\u6765\u63cf\u8ff0 input output \u8d44\u6e90\uff0c\u4f7f\u7528 IDMLBindingTable::BindInputs \u548c IDMLBindingTable::BindOutputs \u6dfb\u52a0\u5230 binding table \u91cc\u3002\u8c03\u7528 IDMLBindingTable::Bind* \u65b9\u6cd5\u65f6, DirectML \u4f1a\u5c06 descriptors \u5199\u5165 CPU descriptors \u4e2d\u3002 DML_BUFFER_BINDING inputBufferBinding { inputBuffer . get (), 0 , tensorBufferSize }; DML_BINDING_DESC inputBindingDesc { DML_BINDING_TYPE_BUFFER , & inputBufferBinding }; dmlBindingTable -> BindInputs ( 1 , & inputBindingDesc ); DML_BUFFER_BINDING outputBufferBinding { outputBuffer . get (), 0 , tensorBufferSize }; DML_BINDING_DESC outputBindingDesc { DML_BINDING_TYPE_BUFFER , & outputBufferBinding }; dmlBindingTable -> BindOutputs ( 1 , & outputBindingDesc ); \u4f7f\u7528 DML_TENSOR_FLAG_OWNED_BY_DML \u6807\u8bc6\uff0c\u8ba9 DirectML \u7ba1\u7406 tensors\u3002DirectML \u5c06\u6570\u636e\u62f7\u8d1d\u3001\u5b58\u50a8\u5230 persistent \u8d44\u6e90\uff0cDirectML \u5c06\u6570\u636e\u8f6c\u5316\u4e3a\u66f4\u9ad8\u6548\u6267\u884c\u7684\u683c\u5f0f\u3002\u5bf9\u4e8e operator \u751f\u547d\u5468\u671f\u4e0d\u53d8\u7684\u6570\u636e\uff08\u4f8b\u5982\u6743\u91cd\uff09\uff0c\u53ef\u4ee5\u63d0\u5347\u6027\u80fd\u3002\u62e5\u6709\u8be5\u6807\u8bc6\u7684\u7684 tensor \u53ea\u80fd\u5728 initializer \u9636\u6bb5\u4f7f\u7528\u3002 \u5bf9\u4e8e\u975e DML_TENSOR_FLAG_OWNED_BY_DML \u6807\u8bc6\u7684 tensor \u5728\u6267\u884c operator \u65f6\u7ed1\u5b9a\u3002 \u6267\u884c Dispatchable \u4f7f\u7528 IDMLCommandRecorder::RecordDispatch \u4f20\u9012 binding table \u53c2\u6570\u3002 \u7a0b\u5e8f\u9700\u4fdd\u8bc1 CPU Descriptors \u590d\u5236\u5230\u4e86 GPU \u4e2d\u3002 winrt :: com_ptr <:: ID3D12GraphicsCommandList > d3D12GraphicsCommandList ; // Code to create a Direct3D 12 command list goes here. winrt :: com_ptr <:: IDMLCommandRecorder > dmlCommandRecorder ; // Code to create a DirectML command recorder goes here. dmlCommandRecorder -> RecordDispatch ( d3D12GraphicsCommandList . get (), dmlOperatorInitializer . get (), dmlBindingTable . get () ); \u5173\u95ed command list\uff0c\u63d0\u4ea4\u6267\u884c\u3002 GPU \u6267\u884c RecordDispatch \u524d\uff0c\u7a0b\u5e8f\u9700\u8981\u5c06\u6240\u6709\u7ed1\u5b9a\u7684\u8d44\u6e90\u8f6c\u6362\u5230 D3D12_RESOURCE_STATE_UNORDERED_ACCESS \u72b6\u6001\uff0c\u6216\u9690\u5f0f\u8f6c\u6362\u5230 D3D12_RESOURCE_STATE_UNORDERED_ACCESS \u7684\u72b6\u6001\uff0c\u4f8b\u5982 D3D12_RESOURCE_STATE_COMMON\u3002 \u4e0a\u8ff0\u4f8b\u5916\u662f upload heaps \u7ed1\u5b9a\u5230\u521d\u59cb\u5316 operator DML_TENSOR_FLAG_OWNED_BY_DML\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cupload heaps \u5e94\u5904\u5728 D3D12_RESOURCE_STATE_GENERIC_READ \u72b6\u6001\u3002 \u5bf9\u4e8e RecordDispatch\uff0c\u9700\u8981\u4f7f\u7528 unordered access view (UAV) barriers \u6765\u4fdd\u8bc1 dispatches \u95f4\u6b63\u786e\u6570\u636e\u4f9d\u8d56\u3002\u793a\u4f8b\u4ee3\u7801\u4e2d\u6ca1\u6709 UAV barriers\uff0c\u5f53 dispatch \u95f4\u6709\u6570\u636e\u4f9d\u8d56\uff08\u540e\u9762 dispatch \u7684 input \u7528\u5230\u4e86\u524d\u9762 dispatch \u7684 output\uff09\uff0c\u5b9e\u9645\u7a0b\u5e8f\u5fc5\u987b\u786e\u4fdd\u6b63\u786e\u7684 UAV barriers\u3002 Descriptors\u3001Binding Table \u7684\u751f\u547d\u5468\u671f\u548c\u540c\u6b65 \u5f53 Descriptor \u88ab\u4f7f\u7528\u65f6\uff08\u4f8b\u5982\uff0c\u88ab\u524d\u4e00\u5e27\u4f7f\u7528\uff09\uff0cbinding table \u65e0\u6cd5\u8986\u5199\uff0c\u7a0b\u5e8f\u9700\u8981\u7b49\u5f85 dispatchable GPU \u4e0a\u7ed3\u675f\u6267\u884c\u3002 Binding table \u4e0d\u6301\u6709 descriptor heap \u7684\u5f3a\u5f15\u7528\uff0c\u56e0\u800c\u7a0b\u5e8f\u5e94\u7b49\u5f85\u4f7f\u7528\u4e86\u8fd9\u4e2a binding table \u7684 dispatchable GPU \u6267\u884c\u7ed3\u675f\u540e\u518d\u91ca\u653e descriptor heap\u3002 Binding table \u4e0d\u4fdd\u8bc1\u7ebf\u7a0b\u5b89\u5168\uff0c\u4e0d\u8981\u5728\u672a\u540c\u6b65\u60c5\u51b5\u4e0b\u591a\u7ebf\u7a0b\u4f7f\u7528 binding table\u3002 \u5bf9\u4e8e ML\u3001CG \u6df7\u5408\u5de5\u4f5c\u6d41\uff0c\u7a0b\u5e8f\u5e94\u4fdd\u8bc1 binding table \u6307\u5411\u7684 descriptor heap \u6ca1\u6709\u6b63\u88ab GPU \u4f7f\u7528\u3002 Binding in DirectML - Windows applications | Microsoft Docs \u21a9 directml.h header | Microsoft Docs \u21a9","title":"\u8d44\u6e90\u7ed1\u5b9a"},{"location":"directx/binding/#directml-1","text":"\u5c06\u8d44\u6e90\u7ed1\u5b9a\u5230 pipeline \u4e0a\uff0cDirectML \u8d44\u6e90\u5305\u542b\u4e0b\u9762\u51e0\u79cd Input Output Temporary Persistent \u672c\u6587\u5305\u542b\u7ed1\u5b9a\u7684\u6982\u5ff5\u53ca\u5b9e\u73b0\u7ec6\u8282","title":"DirectML \u4e2d\u7684\u8d44\u6e90\u7ed1\u5b9a1"},{"location":"directx/binding/#_1","text":"\u6267\u884c dispatchable\uff08operator initializer/ compiled operator\uff09\uff0c\u9700\u4f9d\u7167\u4ee5\u4e0b\u6b65\u9aa4\u8fdb\u884c\u3002 IDMLDispatchable::GetBindingProperties \u83b7\u53d6\u5f53\u524d dispatchable \u6240\u9700\u7684 descriptors \u6570\u91cf\uff0ctemporary/persistent \u8d44\u6e90 \u521b\u5efa\u8db3\u591f\u5bb9\u7eb3 descriptors \u7684 Direct3D 12 descriptor heap\uff0c\u7ed1\u5b9a\u5230 pipeline IDMLDevice::CreateBindingTable \u521b\u5efa DirectML \u7684 binding table\uff0c\u8868\u793a pipeline \u4e0a\u7684\u8d44\u6e90\u3002\u4f7f\u7528 DML_BINDING_TABLE_DESC \u7ed3\u6784\u6765\u63cf\u8ff0 binding table\u3002 \u521b\u5efa Direct3D 12 buffer \u683c\u5f0f\u7684 temporal/persistent \u8d44\u6e90\uff0c \u7528 DML_BUFFER_BINDING \u548c DML_BINDING_DESC \u63cf\u8ff0\uff0c\u6dfb\u52a0\u5230 binding table \u5f53 dispatchable \u4e3a compiled operator \u65f6\uff0c\u521b\u5efa Direct3D 12 buffer \u8d44\u6e90\uff0c\u6dfb\u52a0\u5230 binding table \u5c06 binding table \u4f5c\u4e3a\u53c2\u6570\u4f20\u5165 IDMLCommandRecorder::RecordDispatch","title":"\u91cd\u8981\u6982\u5ff5"},{"location":"directx/binding/#binding-properties","text":"Note \u76f8\u540c\u7684 operator \u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684 binding properties DML_BINDING_PROPERTIES \u7ed3\u6784\u5b9a\u4e49\u4e86 dispatchable \u7ed1\u5b9a\u8d44\u6e90\u76f8\u5173\u6570\u636e\uff0c\u4e0b\u9762\u662f\u7ed3\u6784\u7684\u5b8c\u6574\u5b9a\u4e49 struct DML_BINDING_PROPERTIES { UINT RequiredDescriptorCount ; UINT64 TemporaryResourceSize ; UINT64 PersistentResourceSize ; }; \u4f7f\u7528 IDMLDispatchable::GetBindingProperties \u83b7\u53d6\u6570\u636e winrt :: com_ptr <:: IDMLCompiledOperator > dmlCompiledOperator ; // Code to create and compile a DirectML operator goes here. DML_BINDING_PROPERTIES executeDmlBindingProperties { dmlCompiledOperator -> GetBindingProperties () }; winrt :: com_ptr <:: IDMLOperatorInitializer > dmlOperatorInitializer ; // Code to create a DirectML operator initializer goes here. DML_BINDING_PROPERTIES initializeDmlBindingProperties { dmlOperatorInitializer -> GetBindingProperties () }; UINT descriptorCount = ... RequiredDescriptorCount\uff1aDescriptor Heap size TemporaryResourceSize PersistentResourceSize","title":"\u83b7\u53d6 Binding Properties"},{"location":"directx/binding/#descriptor-heap","text":"DirectML \u5728 Heap \u4e0a\u521b\u5efa\u3001\u7ba1\u7406 Descriptors\u3002 D3D12_DESCRIPTOR_HEAP_DESC \u7ed3\u6784\u63cf\u8ff0 Heap ID3D12Device::CreateDescriptorHeap \u521b\u5efa Heap\u3002 ID3D12GraphicsCommandList::SetDescriptorHeaps \u5c06 Heap \u7ed1\u5b9a\u5230 pipeline\u3002 typedef struct D3D12_DESCRIPTOR_HEAP_DESC { D3D12_DESCRIPTOR_HEAP_TYPE Type ; UINT NumDescriptors ; D3D12_DESCRIPTOR_HEAP_FLAGS Flags ; UINT NodeMask ; } D3D12_DESCRIPTOR_HEAP_DESC ; winrt :: com_ptr <:: ID3D12DescriptorHeap > d3D12DescriptorHeap ; D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription {}; descriptorHeapDescription . Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV ; descriptorHeapDescription . NumDescriptors = descriptorCount ; descriptorHeapDescription . Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE ; winrt :: check_hresult ( d3D12Device -> CreateDescriptorHeap ( & descriptorHeapDescription , _uuidof ( d3D12DescriptorHeap ), d3D12DescriptorHeap . put_void () ) ); std :: array < ID3D12DescriptorHeap * , 1 > d3D12DescriptorHeaps { d3D12DescriptorHeap . get () }; d3D12GraphicsCommandList -> SetDescriptorHeaps ( static_cast < UINT > ( d3D12DescriptorHeaps . size ()), d3D12DescriptorHeaps . data () );","title":"\u521b\u5efa Descriptor Heap"},{"location":"directx/binding/#binding-table","text":"Binding Table \u7528\u4e8e\u8868\u793a dispatchable \u7684\u8d44\u6e90\u3002 Input Output Temporary Persistent DML_BINDING_TABLE_DESC \u7528\u4e8e\u63cf\u8ff0 binding table struct DML_BINDING_TABLE_DESC { IDMLDispatchable * Dispatchable ; D3D12_CPU_DESCRIPTOR_HANDLE CPUDescriptorHandle ; D3D12_GPU_DESCRIPTOR_HANDLE GPUDescriptorHandle ; UINT SizeInDescriptors ; }; IDMLDevice::CreateBindingTable \u65b9\u6cd5\u521b\u5efa DirectML binding table\u3002\u4e4b\u540e\u6211\u4eec\u5c06\u521b\u5efa\u8d44\u6e90\uff0c\u5e76\u5c06\u8fd9\u4e9b\u8d44\u6e90\u6dfb\u52a0\u5230 binding table\u3002 DML_BINDING_TABLE_DESC dmlBindingTableDesc {}; dmlBindingTableDesc . Dispatchable = dmlOperatorInitializer . get (); dmlBindingTableDesc . CPUDescriptorHandle = d3D12DescriptorHeap -> GetCPUDescriptorHandleForHeapStart (); dmlBindingTableDesc . GPUDescriptorHandle = d3D12DescriptorHeap -> GetGPUDescriptorHandleForHeapStart (); dmlBindingTableDesc . SizeInDescriptors = descriptorCount ; winrt :: com_ptr <:: IDMLBindingTable > dmlBindingTable ; winrt :: check_hresult ( dmlDevice -> CreateBindingTable ( & dmlBindingTableDesc , __uuidof ( dmlBindingTable ), dmlBindingTable . put_void () ) ); DirectML \u5c06 Descriptor \u5199\u5165 Heap \u7684\u987a\u5e8f\u672a\u5b9a\u4e49\uff0c\u6ce8\u610f\u4e0d\u8981\u8986\u5199 binding table \u4e2d\u7684 descriptor \u4ee3\u7801\u4e2d\u6ce8\u610f\u5728\u6267\u884cbinding table \u524d\uff0c\u4fdd\u8bc1 CPU descriptors \u62f7\u8d1d\u5230 GPU \u4e2d Handle \u652f\u6301 D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV \u7c7b\u578b\u7684 descriptor heap heap \u5fc5\u987b\u662f shader-visible \u7684 \u91cd\u7f6e binding table \u79fb\u9664\u6240\u6709\u8d44\u6e90 \u4fee\u6539 binding table \u63cf\u8ff0 IDMLBindingTable::Reset dmlBindingTableDesc . Dispatchable = pIDMLCompiledOperator . get (); winrt :: check_hresult ( pIDMLBindingTable -> Reset ( & dmlBindingTableDesc ) );","title":"\u521b\u5efa Binding Table"},{"location":"directx/binding/#temporarypersistent","text":"\u4f7f\u7528\u4ece dispatchable \u4e2d\u83b7\u53d6\u7684 binding \u53c2\u6570\u586b\u5145 DML_BINDING_PROPERTIES \u7ed3\u6784\u3002\u521b\u5efa Direct3D 12 buffer \u8d44\u6e90\uff0c\u6dfb\u52a0\u5230 binding table \u4e2d\u3002 D3D12_HEAP_PROPERTIES defaultHeapProperties { CD3DX12_HEAP_PROPERTIES ( D3D12_HEAP_TYPE_DEFAULT ) }; winrt :: com_ptr <:: ID3D12Resource > temporaryBuffer ; D3D12_RESOURCE_DESC temporaryBufferDesc { CD3DX12_RESOURCE_DESC :: Buffer ( temporaryResourceSize ) }; winrt :: check_hresult ( d3D12Device -> CreateCommittedResource ( & defaultHeapProperties , D3D12_HEAP_FLAG_NONE , & temporaryBufferDesc , D3D12_RESOURCE_STATE_COMMON , nullptr , __uuidof ( temporaryBuffer ), temporaryBuffer . put_void () ) ); DML_BUFFER_BINDING bufferBinding { temporaryBuffer . get (), 0 , temporaryResourceSize }; DML_BINDING_DESC bindingDesc { DML_BINDING_TYPE_BUFFER , & bufferBinding }; dmlBindingTable -> BindTemporaryResource ( & bindingDesc ); temporary \u8d44\u6e90\u662f operator \u6267\u884c\u8fc7\u7a0b\u4e2d\u5185\u90e8\u4f7f\u7528\u7684\u5b58\u50a8\u8d44\u6e90\uff08GPU Memory\uff09\uff0c\u7a0b\u5e8f\u4e0d\u9700\u8981\u5173\u5fc3 temporary \u8d44\u6e90\u7684\u5185\u5bb9\uff0c\u4e5f\u4e0d\u9700\u8981\u5728 IDMLCommandRecorder::RecordDispatch \u6267\u884c\u540e\u4fdd\u7559\u5b83\u3002\u7a0b\u5e8f\u53ef\u4ee5\u9009\u62e9\u91ca\u653e\u8d44\u6e90\uff0c\u6216\u8005\u5728\u4e0d\u540c\u7684 dispatch \u4e0a\u91cd\u7528\u8fd9\u5757\u8d44\u6e90\u3002 \u5bf9\u4e8e persistent \u8d44\u6e90\uff0c\u521b\u5efa\u6d41\u7a0b\u4e0e\u4e0a\u8ff0\u4e00\u81f4\u3002\u4f46\u9700\u4f7f\u7528 IDMLBindingTable::BindOutputs \u5c06\u8d44\u6e90\u6dfb\u52a0\u5230 operator initializer \u7684 binding table \u4e2d\uff0c\u521d\u59cb\u5316 persistent \u8d44\u6e90\u662f initializer \u7684\u804c\u8d23\uff0c\u7136\u540e\u4f7f\u7528 IDMLBindingTable::BindPersistentResource \u7ed1\u5b9a\u5230 compiled operator\u3002persistent \u8d44\u6e90\u7684\u751f\u547d\u5468\u671f\u548c operator \u4e00\u6837\u957f\u3002 persistent \u8d44\u6e90\u901a\u5e38\u7528\u4e8e\u5b58\u50a8\u67e5\u627e\u8868\u6216 operator initialization \u8ba1\u7b97\u51fa\u7684\u6570\u636e\uff0c\u8fd9\u4e9b\u6570\u636e\u88ab operator \u4f7f\u7528\u3002","title":"\u7ed1\u5b9a Temporary/Persistent"},{"location":"directx/binding/#tensors","text":"compiled operator \u9700\u4e3a binding table \u7ed1\u5b9a input \u548c output \u8d44\u6e90\u3002 \u7528 DML_BUFFER_BINDING \u548c DML_BINDING_DESC \u7ed3\u6784\u6765\u63cf\u8ff0 input output \u8d44\u6e90\uff0c\u4f7f\u7528 IDMLBindingTable::BindInputs \u548c IDMLBindingTable::BindOutputs \u6dfb\u52a0\u5230 binding table \u91cc\u3002\u8c03\u7528 IDMLBindingTable::Bind* \u65b9\u6cd5\u65f6, DirectML \u4f1a\u5c06 descriptors \u5199\u5165 CPU descriptors \u4e2d\u3002 DML_BUFFER_BINDING inputBufferBinding { inputBuffer . get (), 0 , tensorBufferSize }; DML_BINDING_DESC inputBindingDesc { DML_BINDING_TYPE_BUFFER , & inputBufferBinding }; dmlBindingTable -> BindInputs ( 1 , & inputBindingDesc ); DML_BUFFER_BINDING outputBufferBinding { outputBuffer . get (), 0 , tensorBufferSize }; DML_BINDING_DESC outputBindingDesc { DML_BINDING_TYPE_BUFFER , & outputBufferBinding }; dmlBindingTable -> BindOutputs ( 1 , & outputBindingDesc ); \u4f7f\u7528 DML_TENSOR_FLAG_OWNED_BY_DML \u6807\u8bc6\uff0c\u8ba9 DirectML \u7ba1\u7406 tensors\u3002DirectML \u5c06\u6570\u636e\u62f7\u8d1d\u3001\u5b58\u50a8\u5230 persistent \u8d44\u6e90\uff0cDirectML \u5c06\u6570\u636e\u8f6c\u5316\u4e3a\u66f4\u9ad8\u6548\u6267\u884c\u7684\u683c\u5f0f\u3002\u5bf9\u4e8e operator \u751f\u547d\u5468\u671f\u4e0d\u53d8\u7684\u6570\u636e\uff08\u4f8b\u5982\u6743\u91cd\uff09\uff0c\u53ef\u4ee5\u63d0\u5347\u6027\u80fd\u3002\u62e5\u6709\u8be5\u6807\u8bc6\u7684\u7684 tensor \u53ea\u80fd\u5728 initializer \u9636\u6bb5\u4f7f\u7528\u3002 \u5bf9\u4e8e\u975e DML_TENSOR_FLAG_OWNED_BY_DML \u6807\u8bc6\u7684 tensor \u5728\u6267\u884c operator \u65f6\u7ed1\u5b9a\u3002","title":"\u7ed1\u5b9a Tensors"},{"location":"directx/binding/#dispatchable","text":"\u4f7f\u7528 IDMLCommandRecorder::RecordDispatch \u4f20\u9012 binding table \u53c2\u6570\u3002 \u7a0b\u5e8f\u9700\u4fdd\u8bc1 CPU Descriptors \u590d\u5236\u5230\u4e86 GPU \u4e2d\u3002 winrt :: com_ptr <:: ID3D12GraphicsCommandList > d3D12GraphicsCommandList ; // Code to create a Direct3D 12 command list goes here. winrt :: com_ptr <:: IDMLCommandRecorder > dmlCommandRecorder ; // Code to create a DirectML command recorder goes here. dmlCommandRecorder -> RecordDispatch ( d3D12GraphicsCommandList . get (), dmlOperatorInitializer . get (), dmlBindingTable . get () ); \u5173\u95ed command list\uff0c\u63d0\u4ea4\u6267\u884c\u3002 GPU \u6267\u884c RecordDispatch \u524d\uff0c\u7a0b\u5e8f\u9700\u8981\u5c06\u6240\u6709\u7ed1\u5b9a\u7684\u8d44\u6e90\u8f6c\u6362\u5230 D3D12_RESOURCE_STATE_UNORDERED_ACCESS \u72b6\u6001\uff0c\u6216\u9690\u5f0f\u8f6c\u6362\u5230 D3D12_RESOURCE_STATE_UNORDERED_ACCESS \u7684\u72b6\u6001\uff0c\u4f8b\u5982 D3D12_RESOURCE_STATE_COMMON\u3002 \u4e0a\u8ff0\u4f8b\u5916\u662f upload heaps \u7ed1\u5b9a\u5230\u521d\u59cb\u5316 operator DML_TENSOR_FLAG_OWNED_BY_DML\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cupload heaps \u5e94\u5904\u5728 D3D12_RESOURCE_STATE_GENERIC_READ \u72b6\u6001\u3002 \u5bf9\u4e8e RecordDispatch\uff0c\u9700\u8981\u4f7f\u7528 unordered access view (UAV) barriers \u6765\u4fdd\u8bc1 dispatches \u95f4\u6b63\u786e\u6570\u636e\u4f9d\u8d56\u3002\u793a\u4f8b\u4ee3\u7801\u4e2d\u6ca1\u6709 UAV barriers\uff0c\u5f53 dispatch \u95f4\u6709\u6570\u636e\u4f9d\u8d56\uff08\u540e\u9762 dispatch \u7684 input \u7528\u5230\u4e86\u524d\u9762 dispatch \u7684 output\uff09\uff0c\u5b9e\u9645\u7a0b\u5e8f\u5fc5\u987b\u786e\u4fdd\u6b63\u786e\u7684 UAV barriers\u3002","title":"\u6267\u884c Dispatchable"},{"location":"directx/binding/#descriptorsbinding-table","text":"\u5f53 Descriptor \u88ab\u4f7f\u7528\u65f6\uff08\u4f8b\u5982\uff0c\u88ab\u524d\u4e00\u5e27\u4f7f\u7528\uff09\uff0cbinding table \u65e0\u6cd5\u8986\u5199\uff0c\u7a0b\u5e8f\u9700\u8981\u7b49\u5f85 dispatchable GPU \u4e0a\u7ed3\u675f\u6267\u884c\u3002 Binding table \u4e0d\u6301\u6709 descriptor heap \u7684\u5f3a\u5f15\u7528\uff0c\u56e0\u800c\u7a0b\u5e8f\u5e94\u7b49\u5f85\u4f7f\u7528\u4e86\u8fd9\u4e2a binding table \u7684 dispatchable GPU \u6267\u884c\u7ed3\u675f\u540e\u518d\u91ca\u653e descriptor heap\u3002 Binding table \u4e0d\u4fdd\u8bc1\u7ebf\u7a0b\u5b89\u5168\uff0c\u4e0d\u8981\u5728\u672a\u540c\u6b65\u60c5\u51b5\u4e0b\u591a\u7ebf\u7a0b\u4f7f\u7528 binding table\u3002 \u5bf9\u4e8e ML\u3001CG \u6df7\u5408\u5de5\u4f5c\u6d41\uff0c\u7a0b\u5e8f\u5e94\u4fdd\u8bc1 binding table \u6307\u5411\u7684 descriptor heap \u6ca1\u6709\u6b63\u88ab GPU \u4f7f\u7528\u3002 Binding in DirectML - Windows applications | Microsoft Docs \u21a9 directml.h header | Microsoft Docs \u21a9","title":"Descriptors\u3001Binding Table \u7684\u751f\u547d\u5468\u671f\u548c\u540c\u6b65"},{"location":"directx/directml/","text":"DirectML \u5b98\u65b9\u6982\u8ff0 Direct Machine Learning (DirectML) is a low-level API for machine learning (ML). Hardware-accelerated machine learning primitives (called operators) are the building blocks of DirectML. From those building blocks, you can develop such machine learning techniques as upscaling, anti-aliasing, and style transfer, to name but a few. Denoising and super-resolution, for example, allow you to achieve impressive raytraced effects with fewer rays per pixel. Prerequisites DirectX 12-capable GPU drivers Windows 10 version 1903 or newer Windows 10 SDK version 1903 DirectML Resource The key to resource binding in DirectX 12 are the concepts of a descriptor, descriptor tables, descriptor heaps, and a root signature. A descriptor is a small object that contains information about one resource. typedef struct D3D12_SHADER_RESOURCE_VIEW_DESC { DXGI_FORMAT Format ; D3D12_SRV_DIMENSION ViewDimension ; union { D3D12_BUFFER_SRV Buffer ; D3D12_TEX1D_SRV Texture1D ; D3D12_TEX1D_ARRAY_SRV Texture1DArray ; D3D12_TEX2D_SRV Texture2D ; D3D12_TEX2D_ARRAY_SRV Texture2DArray ; D3D12_TEX2DMS_SRV Texture2DMS ; D3D12_TEX2DMS_ARRAY_SRV Texture2DMSArray ; D3D12_TEX3D_SRV Texture3D ; D3D12_TEXCUBE_SRV TextureCube ; D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray ; D3D12_BUFFEREX_SRV BufferEx ; }; } D3D12_SHADER_RESOURCE_VIEW_DESC ; interface ID3D12Device { ... void CreateShaderResourceView ( _In_opt_ ID3D12Resource * pResource , _In_opt_ const D3D12_SHADER_RESOURCE_VIEW_DESC * pDesc , _In_ D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor ); }; // create SRV D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc ; ZeroMemory ( & srvDesc , sizeof ( D3D12_SHADER_RESOURCE_VIEW_DESC )); srvDesc . Format = mTexture -> Format ; srvDesc . ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D ; srvDesc . Texture2D . MipLevels = 1 ; mDevice -> CreateShaderResourceView ( mTexture . Get (), & srvDesc , mCbvSrvDescriptorHeap -> GetCPUDescriptorHandleForHeapStart ()); Descriptor\uff1a \u63cf\u8ff0 GPU \u4e2d\u8d44\u6e90\u7c7b\u578b\u3001\u6570\u636e\u683c\u5f0f\u3001\u5b58\u50a8\u5730\u5740\u3002 \u5e38\u89c1\u7684 Descriptor \u7c7b\u578b: Constant buffer views (CBVs) Unordered access views (UAVs) Shader resource views (SRVs) Samplers Descriptor Table\uff1aDescriptors \u5206\u7c7b\u5b58\u5165 Descriptor Table Descriptor Heap\uff1aDescriptors \u5b58\u50a8\u5728 Descriptor Heap \u4e2d Topic Description Descriptor Descriptor Heap Descriptor Table Root Singature Descriptor \u521b\u5efa\u6d41\u7a0b\uff1a GPU \u521b\u5efa Descriptor Heap GPU \u521b\u5efa\u8d44\u6e90 GPU \u5229\u7528 1. \u521b\u5efa Descriptor Table \uff08\u53ef\u9009\uff09 GPU \u5229\u7528 1.2. \u7684\u4fe1\u606f\uff0c\u5728 Descriptor Heap / Table \u4e0a\u521b\u5efa Descriptor Windows provides APIs and components that support graphics, gaming, and imaging. \u21a9 Introduction to Resource Binding in Microsoft DirectX 12 \u21a9 Microsoft DirectX* 12 \u4e2d\u8d44\u6e90\u7ed1\u5b9a\u7684\u6027\u80fd\u8003\u8651\u56e0\u7d20 \u21a9 DirectML API \u6587\u6863 \u21a9","title":"DirectML \u6307\u5357"},{"location":"directx/directml/#prerequisites","text":"DirectX 12-capable GPU drivers Windows 10 version 1903 or newer Windows 10 SDK version 1903","title":"Prerequisites"},{"location":"directx/directml/#directml-resource","text":"The key to resource binding in DirectX 12 are the concepts of a descriptor, descriptor tables, descriptor heaps, and a root signature. A descriptor is a small object that contains information about one resource. typedef struct D3D12_SHADER_RESOURCE_VIEW_DESC { DXGI_FORMAT Format ; D3D12_SRV_DIMENSION ViewDimension ; union { D3D12_BUFFER_SRV Buffer ; D3D12_TEX1D_SRV Texture1D ; D3D12_TEX1D_ARRAY_SRV Texture1DArray ; D3D12_TEX2D_SRV Texture2D ; D3D12_TEX2D_ARRAY_SRV Texture2DArray ; D3D12_TEX2DMS_SRV Texture2DMS ; D3D12_TEX2DMS_ARRAY_SRV Texture2DMSArray ; D3D12_TEX3D_SRV Texture3D ; D3D12_TEXCUBE_SRV TextureCube ; D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray ; D3D12_BUFFEREX_SRV BufferEx ; }; } D3D12_SHADER_RESOURCE_VIEW_DESC ; interface ID3D12Device { ... void CreateShaderResourceView ( _In_opt_ ID3D12Resource * pResource , _In_opt_ const D3D12_SHADER_RESOURCE_VIEW_DESC * pDesc , _In_ D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor ); }; // create SRV D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc ; ZeroMemory ( & srvDesc , sizeof ( D3D12_SHADER_RESOURCE_VIEW_DESC )); srvDesc . Format = mTexture -> Format ; srvDesc . ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D ; srvDesc . Texture2D . MipLevels = 1 ; mDevice -> CreateShaderResourceView ( mTexture . Get (), & srvDesc , mCbvSrvDescriptorHeap -> GetCPUDescriptorHandleForHeapStart ()); Descriptor\uff1a \u63cf\u8ff0 GPU \u4e2d\u8d44\u6e90\u7c7b\u578b\u3001\u6570\u636e\u683c\u5f0f\u3001\u5b58\u50a8\u5730\u5740\u3002 \u5e38\u89c1\u7684 Descriptor \u7c7b\u578b: Constant buffer views (CBVs) Unordered access views (UAVs) Shader resource views (SRVs) Samplers Descriptor Table\uff1aDescriptors \u5206\u7c7b\u5b58\u5165 Descriptor Table Descriptor Heap\uff1aDescriptors \u5b58\u50a8\u5728 Descriptor Heap \u4e2d Topic Description Descriptor Descriptor Heap Descriptor Table Root Singature Descriptor \u521b\u5efa\u6d41\u7a0b\uff1a GPU \u521b\u5efa Descriptor Heap GPU \u521b\u5efa\u8d44\u6e90 GPU \u5229\u7528 1. \u521b\u5efa Descriptor Table \uff08\u53ef\u9009\uff09 GPU \u5229\u7528 1.2. \u7684\u4fe1\u606f\uff0c\u5728 Descriptor Heap / Table \u4e0a\u521b\u5efa Descriptor Windows provides APIs and components that support graphics, gaming, and imaging. \u21a9 Introduction to Resource Binding in Microsoft DirectX 12 \u21a9 Microsoft DirectX* 12 \u4e2d\u8d44\u6e90\u7ed1\u5b9a\u7684\u6027\u80fd\u8003\u8651\u56e0\u7d20 \u21a9 DirectML API \u6587\u6863 \u21a9","title":"DirectML Resource"},{"location":"directx/project/","text":"\u5c0f\u7ec4\u9879\u76ee \u5c1d\u8bd5\u8be5 Join Operator 1 \u8fdb\u884c\u7c7b\u4f3c torch.cat \u7684\u64cd\u4f5c struct DML_JOIN_OPERATOR_DESC { UINT InputCount ; _In_reads_ ( InputCount ) const DML_TENSOR_DESC * InputTensors ; const DML_TENSOR_DESC * OutputTensor ; UINT Axis ; }; DirectML API \u6587\u6863 \u21a9","title":"\u5c0f\u7ec4\u9879\u76ee"},{"location":"directx/project/#_1","text":"\u5c1d\u8bd5\u8be5 Join Operator 1 \u8fdb\u884c\u7c7b\u4f3c torch.cat \u7684\u64cd\u4f5c struct DML_JOIN_OPERATOR_DESC { UINT InputCount ; _In_reads_ ( InputCount ) const DML_TENSOR_DESC * InputTensors ; const DML_TENSOR_DESC * OutputTensor ; UINT Axis ; }; DirectML API \u6587\u6863 \u21a9","title":"\u5c0f\u7ec4\u9879\u76ee"}]}